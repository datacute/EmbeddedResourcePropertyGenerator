using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Datacute.EmbeddedResourcePropertyGenerator
{
    public readonly struct CodeGenerator
    {
        public CodeGenerator(in AttributeContext context,
            string resourceSearchPath,
            in ImmutableArray<AdditionalText> additionalTexts,
            in GeneratorOptions options,
            in CancellationToken cancellationToken)
        {
            _context = context;
            _resourceSearchPath = resourceSearchPath;
            _additionalTexts = additionalTexts;
            _options = options;
            _cancellationToken = cancellationToken;
            _buffer = new StringBuilder();
            _propertyNames = new Dictionary<string, AdditionalText>();
        }

        private readonly AttributeContext _context;
        private readonly string _resourceSearchPath;
        private readonly ImmutableArray<AdditionalText> _additionalTexts;
        private readonly GeneratorOptions _options;
        private readonly StringBuilder _buffer;
        private readonly CancellationToken _cancellationToken;
        
        private readonly Dictionary<string, AdditionalText> _propertyNames;

        public string GenerateSource()
        {
            _cancellationToken.ThrowIfCancellationRequested();
            _buffer.Clear();
            GeneratePropertyNames();
            AutoGeneratedComment();
            StartNamespace();
            ClassDocComments();
            PartialTypeDeclaration();
            AppendStartClass();
            AppendStartEmbeddedResourceClass();
            ReadMethod();
            BackingFields();
            ResourceNames();
            AppendEndClass(4);
            AppendPartialMethods();
            ProcessMatchingAdditionalFiles();
            AppendEndClass();
            return _buffer.ToString();
        }

        private void GeneratePropertyNames()
        {
            _propertyNames.Clear();
            foreach (var text in _additionalTexts)
            {
                _cancellationToken.ThrowIfCancellationRequested();
                var resourceFilePath = text.Path;

                if (!FileIsInMatchingFolder(resourceFilePath))
                {
                    continue;
                }

                var propertyName = resourceFilePath.GetPropertyName(_context.Name);
                RecordPropertyNameForResource(propertyName, text);
            }
        }

        private void RecordPropertyNameForResource(string propertyName, AdditionalText text)
        {
            // finding "Classname.txt" (converted to "Classname_txt")
            // before an actual "Classname_txt.txt"
            // should result in "Classname.txt" being adjusted further
            if (_propertyNames.TryGetValue(propertyName, out var existingText))
            {
                if (existingText.Path.Length >= text.Path.Length)
                {
                    RecordPropertyNameForResource(propertyName + "_", text);
                }
                else
                {
                    _propertyNames[propertyName] = text;
                    RecordPropertyNameForResource(propertyName + "_", existingText);
                }
            }
            else
            {
                _propertyNames.Add(propertyName, text);
            }
        }

        private void AutoGeneratedComment() => _buffer.AppendLine(Templates.AutoGeneratedComment);

        private void StartNamespace()
        {
            if (_context.ContainingNamespaceIsGlobalNamespace) return;

            _buffer.Append("namespace ");
            _buffer.Append(_context.ContainingNamespaceDisplayString);
            _buffer.Append(';').AppendLine();
        }

        private void ReadMethod()
        {
            if (_options.IsDesignTimeBuild) return;

            _buffer.AppendFormat(Templates.ReadMethod, _context.Name);
        }

        private void BackingFields()
        {
            if (_options.IsDesignTimeBuild) return;

            _buffer.AppendLine(Templates.BackingFieldClass);

            foreach (var propertyName in _propertyNames.Keys)
            {
                _cancellationToken.ThrowIfCancellationRequested();
                _buffer.AppendFormat(Templates.BackingField, propertyName);
            }

            AppendEndClass(8);
        }

        private void ResourceNames()
        {
            if (_options.IsDesignTimeBuild) return;

            _buffer.AppendLine(Templates.ResourceNameClass);

            foreach (var kvp in _propertyNames)
            {
                _cancellationToken.ThrowIfCancellationRequested();

                var propertyName = kvp.Key;
                var text = kvp.Value;
                var resourceFilePath = text.Path;

                var embeddedResourceName = resourceFilePath.GetEmbeddedResourceName(
                    _options.ProjectDir,
                    _options.RootNamespace);

                _buffer.AppendFormat(Templates.ResourceName, propertyName, embeddedResourceName);
            }
            AppendEndClass(8);
        }

        private void ClassDocComments()
        {
            if (_options.IsDesignTimeBuild) return;

            var path = _resourceSearchPath.Substring(_options.ProjectDir.Length);
            _buffer.AppendFormat(Templates.ClassDocComments, path, _context.ExtensionArg);
        }

        private void PartialTypeDeclaration()
        {
            _buffer.AppendFormat(
                "{0}{1}partial {2} {3}",
                GetAccessibility(),
                GetStatic(),
                _context.RecordStructOrClass,
                _context.Name
            ).AppendLine();
        }

        private string GetAccessibility()
        {
            var accessibility = _context.DeclaredAccessibility;
            switch (accessibility)
            {
                case Accessibility.Private:
                    return "private ";
                case Accessibility.ProtectedAndInternal:
                    return "private protected ";
                case Accessibility.Protected:
                    return "protected ";
                case Accessibility.Internal:
                    return "internal ";
                case Accessibility.ProtectedOrInternal:
                    return "protected internal ";
                case Accessibility.Public:
                    return "public ";
                default:
                    throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null);
            }
        }

        private string GetStatic() => _context.IsStatic ? "static " : "";

        private void AppendStartClass() => _buffer.AppendLine("{");
        private void AppendStartEmbeddedResourceClass() => _buffer.AppendLine(Templates.StartEmbeddedResourceClass);

        private void AppendPartialMethods() => _buffer.AppendLine(Templates.PartialMethods);

        private void ProcessMatchingAdditionalFiles()
        {
            foreach (var kvp in _propertyNames)
            {
                _cancellationToken.ThrowIfCancellationRequested();

                var propertyName = kvp.Key;
                var text = kvp.Value;
                var resourceFilePath = text.Path;

                if (_options.IsDesignTimeBuild)
                {
                    _buffer.AppendFormat(Templates.DesignTimePropertyTemplate, propertyName);
                }
                else
                {
                    var sourceText = text.GetText(_cancellationToken);
                    if (sourceText is null)
                    {
                        continue;
                    }

                    var resourceFileName = resourceFilePath.GetFileName();

                    var docCommentCode = GeneratePropertyDocCommentCode(sourceText);

                    _buffer.AppendFormat(Templates.PropertyTemplate,
                        propertyName,
                        resourceFileName,
                        docCommentCode);
                }
            }
        }

        private bool FileIsInMatchingFolder(string resourceFilePath) =>
            Path.GetDirectoryName(resourceFilePath) == _resourceSearchPath
            && Path.GetExtension(resourceFilePath) == _context.ExtensionArg;

        private string GeneratePropertyDocCommentCode(SourceText sourceText)
        {
            var sb = new StringBuilder();
            var textLineCollection = sourceText.Lines;
            var lineCount = textLineCollection.Count;
            var outputLines = 0;
            foreach (var textLine in textLineCollection)
            {
                outputLines++;
                if (outputLines > 10 && lineCount > outputLines + 1)
                {
                    var moreLines = $"... {lineCount - outputLines} more lines";
                    sb.AppendLine()
                        .Append("    /// ").Append(moreLines);
                    break;
                }
                var textString = textLine.ToString();
                var escapedLine = EscapeStringForDocComments(textString);
                sb.AppendLine()
                    .Append("    /// ").Append(escapedLine);
            }

            return sb.ToString();
        }

        private string EscapeStringForDocComments(string input) =>
            input.Replace("&", "&amp;")
                .Replace("<", "&lt;")
                .Replace(">", "&gt;")
                .Replace("\"", "&quot;")
                .Replace("'", "&apos;");

        private void AppendEndClass(int indent = 0)
        {
            _buffer.Append(' ', indent);
            _buffer.AppendLine("}");
        }
    }
}